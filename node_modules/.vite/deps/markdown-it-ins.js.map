{
  "version": 3,
  "sources": ["../../markdown-it-ins/index.js", "dep:markdown-it-ins"],
  "sourcesContent": ["'use strict';\n\n\nmodule.exports = function ins_plugin(md) {\n  // Insert each marker as a separate text token, and add it to delimiter list\n  //\n  function tokenize(state, silent) {\n    var i, scanned, token, len, ch,\n        start = state.pos,\n        marker = state.src.charCodeAt(start);\n\n    if (silent) { return false; }\n\n    if (marker !== 0x2B/* + */) { return false; }\n\n    scanned = state.scanDelims(state.pos, true);\n    len = scanned.length;\n    ch = String.fromCharCode(marker);\n\n    if (len < 2) { return false; }\n\n    if (len % 2) {\n      token         = state.push('text', '', 0);\n      token.content = ch;\n      len--;\n    }\n\n    for (i = 0; i < len; i += 2) {\n      token         = state.push('text', '', 0);\n      token.content = ch + ch;\n\n      if (!scanned.can_open && !scanned.can_close) { continue; }\n\n      state.delimiters.push({\n        marker: marker,\n        length: 0,     // disable \"rule of 3\" length checks meant for emphasis\n        jump:   i / 2, // 1 delimiter = 2 characters\n        token:  state.tokens.length - 1,\n        end:    -1,\n        open:   scanned.can_open,\n        close:  scanned.can_close\n      });\n    }\n\n    state.pos += scanned.length;\n\n    return true;\n  }\n\n\n  // Walk through delimiter list and replace text tokens with tags\n  //\n  function postProcess(state, delimiters) {\n    var i, j,\n        startDelim,\n        endDelim,\n        token,\n        loneMarkers = [],\n        max = delimiters.length;\n\n    for (i = 0; i < max; i++) {\n      startDelim = delimiters[i];\n\n      if (startDelim.marker !== 0x2B/* + */) {\n        continue;\n      }\n\n      if (startDelim.end === -1) {\n        continue;\n      }\n\n      endDelim = delimiters[startDelim.end];\n\n      token         = state.tokens[startDelim.token];\n      token.type    = 'ins_open';\n      token.tag     = 'ins';\n      token.nesting = 1;\n      token.markup  = '++';\n      token.content = '';\n\n      token         = state.tokens[endDelim.token];\n      token.type    = 'ins_close';\n      token.tag     = 'ins';\n      token.nesting = -1;\n      token.markup  = '++';\n      token.content = '';\n\n      if (state.tokens[endDelim.token - 1].type === 'text' &&\n          state.tokens[endDelim.token - 1].content === '+') {\n\n        loneMarkers.push(endDelim.token - 1);\n      }\n    }\n\n    // If a marker sequence has an odd number of characters, it's splitted\n    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n    // start of the sequence.\n    //\n    // So, we have to move all those markers after subsequent s_close tags.\n    //\n    while (loneMarkers.length) {\n      i = loneMarkers.pop();\n      j = i + 1;\n\n      while (j < state.tokens.length && state.tokens[j].type === 'ins_close') {\n        j++;\n      }\n\n      j--;\n\n      if (i !== j) {\n        token = state.tokens[j];\n        state.tokens[j] = state.tokens[i];\n        state.tokens[i] = token;\n      }\n    }\n  }\n\n  md.inline.ruler.before('emphasis', 'ins', tokenize);\n  md.inline.ruler2.before('emphasis', 'ins', function (state) {\n    var curr,\n        tokens_meta = state.tokens_meta,\n        max = (state.tokens_meta || []).length;\n\n    postProcess(state, state.delimiters);\n\n    for (curr = 0; curr < max; curr++) {\n      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n        postProcess(state, tokens_meta[curr].delimiters);\n      }\n    }\n  });\n};\n", "export default require(\"./node_modules/markdown-it-ins/index.js\");"],
  "mappings": "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",
  "names": []
}
