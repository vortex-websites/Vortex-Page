import {
  __commonJS
} from "./chunk-FJLWZCXQ.js";

// node_modules/markdown-it-deflist/index.js
var require_markdown_it_deflist = __commonJS({
  "node_modules/markdown-it-deflist/index.js"(exports, module) {
    "use strict";
    module.exports = function deflist_plugin(md) {
      var isSpace = md.utils.isSpace;
      function skipMarker(state, line) {
        var pos, marker, start = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
        if (start >= max) {
          return -1;
        }
        marker = state.src.charCodeAt(start++);
        if (marker !== 126 && marker !== 58) {
          return -1;
        }
        pos = state.skipSpaces(start);
        if (start === pos) {
          return -1;
        }
        if (pos >= max) {
          return -1;
        }
        return start;
      }
      function markTightParagraphs(state, idx) {
        var i, l, level = state.level + 2;
        for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
          if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
            state.tokens[i + 2].hidden = true;
            state.tokens[i].hidden = true;
            i += 2;
          }
        }
      }
      function deflist(state, startLine, endLine, silent) {
        var ch, contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, max, nextLine, offset, oldDDIndent, oldIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, prevEmptyEnd, tight, token;
        if (silent) {
          if (state.ddIndent < 0) {
            return false;
          }
          return skipMarker(state, startLine) >= 0;
        }
        nextLine = startLine + 1;
        if (nextLine >= endLine) {
          return false;
        }
        if (state.isEmpty(nextLine)) {
          nextLine++;
          if (nextLine >= endLine) {
            return false;
          }
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          return false;
        }
        contentStart = skipMarker(state, nextLine);
        if (contentStart < 0) {
          return false;
        }
        listTokIdx = state.tokens.length;
        tight = true;
        token = state.push("dl_open", "dl", 1);
        token.map = listLines = [startLine, 0];
        dtLine = startLine;
        ddLine = nextLine;
        OUTER:
          for (; ; ) {
            prevEmptyEnd = false;
            token = state.push("dt_open", "dt", 1);
            token.map = [dtLine, dtLine];
            token = state.push("inline", "", 0);
            token.map = [dtLine, dtLine];
            token.content = state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim();
            token.children = [];
            token = state.push("dt_close", "dt", -1);
            for (; ; ) {
              token = state.push("dd_open", "dd", 1);
              token.map = itemLines = [nextLine, 0];
              pos = contentStart;
              max = state.eMarks[ddLine];
              offset = state.sCount[ddLine] + contentStart - (state.bMarks[ddLine] + state.tShift[ddLine]);
              while (pos < max) {
                ch = state.src.charCodeAt(pos);
                if (isSpace(ch)) {
                  if (ch === 9) {
                    offset += 4 - offset % 4;
                  } else {
                    offset++;
                  }
                } else {
                  break;
                }
                pos++;
              }
              contentStart = pos;
              oldTight = state.tight;
              oldDDIndent = state.ddIndent;
              oldIndent = state.blkIndent;
              oldTShift = state.tShift[ddLine];
              oldSCount = state.sCount[ddLine];
              oldParentType = state.parentType;
              state.blkIndent = state.ddIndent = state.sCount[ddLine] + 2;
              state.tShift[ddLine] = contentStart - state.bMarks[ddLine];
              state.sCount[ddLine] = offset;
              state.tight = true;
              state.parentType = "deflist";
              state.md.block.tokenize(state, ddLine, endLine, true);
              if (!state.tight || prevEmptyEnd) {
                tight = false;
              }
              prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);
              state.tShift[ddLine] = oldTShift;
              state.sCount[ddLine] = oldSCount;
              state.tight = oldTight;
              state.parentType = oldParentType;
              state.blkIndent = oldIndent;
              state.ddIndent = oldDDIndent;
              token = state.push("dd_close", "dd", -1);
              itemLines[1] = nextLine = state.line;
              if (nextLine >= endLine) {
                break OUTER;
              }
              if (state.sCount[nextLine] < state.blkIndent) {
                break OUTER;
              }
              contentStart = skipMarker(state, nextLine);
              if (contentStart < 0) {
                break;
              }
              ddLine = nextLine;
            }
            if (nextLine >= endLine) {
              break;
            }
            dtLine = nextLine;
            if (state.isEmpty(dtLine)) {
              break;
            }
            if (state.sCount[dtLine] < state.blkIndent) {
              break;
            }
            ddLine = dtLine + 1;
            if (ddLine >= endLine) {
              break;
            }
            if (state.isEmpty(ddLine)) {
              ddLine++;
            }
            if (ddLine >= endLine) {
              break;
            }
            if (state.sCount[ddLine] < state.blkIndent) {
              break;
            }
            contentStart = skipMarker(state, ddLine);
            if (contentStart < 0) {
              break;
            }
          }
        token = state.push("dl_close", "dl", -1);
        listLines[1] = nextLine;
        state.line = nextLine;
        if (tight) {
          markTightParagraphs(state, listTokIdx);
        }
        return true;
      }
      md.block.ruler.before("paragraph", "deflist", deflist, { alt: ["paragraph", "reference", "blockquote"] });
    };
  }
});

// dep:markdown-it-deflist
var markdown_it_deflist_default = require_markdown_it_deflist();
export {
  markdown_it_deflist_default as default
};
//# sourceMappingURL=markdown-it-deflist.js.map
