{
  "version": 3,
  "sources": ["../../markdown-it-deflist/index.js", "dep:markdown-it-deflist"],
  "sourcesContent": ["// Process definition lists\n//\n'use strict';\n\n\nmodule.exports = function deflist_plugin(md) {\n  var isSpace = md.utils.isSpace;\n\n  // Search `[:~][\\n ]`, returns next pos after marker on success\n  // or -1 on fail.\n  function skipMarker(state, line) {\n    var pos, marker,\n        start = state.bMarks[line] + state.tShift[line],\n        max = state.eMarks[line];\n\n    if (start >= max) { return -1; }\n\n    // Check bullet\n    marker = state.src.charCodeAt(start++);\n    if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }\n\n    pos = state.skipSpaces(start);\n\n    // require space after \":\"\n    if (start === pos) { return -1; }\n\n    // no empty definitions, e.g. \"  : \"\n    if (pos >= max) { return -1; }\n\n    return start;\n  }\n\n  function markTightParagraphs(state, idx) {\n    var i, l,\n        level = state.level + 2;\n\n    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n      if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n        state.tokens[i + 2].hidden = true;\n        state.tokens[i].hidden = true;\n        i += 2;\n      }\n    }\n  }\n\n  function deflist(state, startLine, endLine, silent) {\n    var ch,\n        contentStart,\n        ddLine,\n        dtLine,\n        itemLines,\n        listLines,\n        listTokIdx,\n        max,\n        nextLine,\n        offset,\n        oldDDIndent,\n        oldIndent,\n        oldParentType,\n        oldSCount,\n        oldTShift,\n        oldTight,\n        pos,\n        prevEmptyEnd,\n        tight,\n        token;\n\n    if (silent) {\n      // quirk: validation mode validates a dd block only, not a whole deflist\n      if (state.ddIndent < 0) { return false; }\n      return skipMarker(state, startLine) >= 0;\n    }\n\n    nextLine = startLine + 1;\n    if (nextLine >= endLine) { return false; }\n\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      if (nextLine >= endLine) { return false; }\n    }\n\n    if (state.sCount[nextLine] < state.blkIndent) { return false; }\n    contentStart = skipMarker(state, nextLine);\n    if (contentStart < 0) { return false; }\n\n    // Start list\n    listTokIdx = state.tokens.length;\n    tight = true;\n\n    token     = state.push('dl_open', 'dl', 1);\n    token.map = listLines = [ startLine, 0 ];\n\n    //\n    // Iterate list items\n    //\n\n    dtLine = startLine;\n    ddLine = nextLine;\n\n    // One definition list can contain multiple DTs,\n    // and one DT can be followed by multiple DDs.\n    //\n    // Thus, there is two loops here, and label is\n    // needed to break out of the second one\n    //\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER:\n    for (;;) {\n      prevEmptyEnd = false;\n\n      token          = state.push('dt_open', 'dt', 1);\n      token.map      = [ dtLine, dtLine ];\n\n      token          = state.push('inline', '', 0);\n      token.map      = [ dtLine, dtLine ];\n      token.content  = state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim();\n      token.children = [];\n\n      token          = state.push('dt_close', 'dt', -1);\n\n      for (;;) {\n        token     = state.push('dd_open', 'dd', 1);\n        token.map = itemLines = [ nextLine, 0 ];\n\n        pos = contentStart;\n        max = state.eMarks[ddLine];\n        offset = state.sCount[ddLine] + contentStart - (state.bMarks[ddLine] + state.tShift[ddLine]);\n\n        while (pos < max) {\n          ch = state.src.charCodeAt(pos);\n\n          if (isSpace(ch)) {\n            if (ch === 0x09) {\n              offset += 4 - offset % 4;\n            } else {\n              offset++;\n            }\n          } else {\n            break;\n          }\n\n          pos++;\n        }\n\n        contentStart = pos;\n\n        oldTight = state.tight;\n        oldDDIndent = state.ddIndent;\n        oldIndent = state.blkIndent;\n        oldTShift = state.tShift[ddLine];\n        oldSCount = state.sCount[ddLine];\n        oldParentType = state.parentType;\n        state.blkIndent = state.ddIndent = state.sCount[ddLine] + 2;\n        state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n        state.sCount[ddLine] = offset;\n        state.tight = true;\n        state.parentType = 'deflist';\n\n        state.md.block.tokenize(state, ddLine, endLine, true);\n\n        // If any of list item is tight, mark list as tight\n        if (!state.tight || prevEmptyEnd) {\n          tight = false;\n        }\n        // Item become loose if finish with empty line,\n        // but we should filter last element, because it means list finish\n        prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);\n\n        state.tShift[ddLine] = oldTShift;\n        state.sCount[ddLine] = oldSCount;\n        state.tight = oldTight;\n        state.parentType = oldParentType;\n        state.blkIndent = oldIndent;\n        state.ddIndent = oldDDIndent;\n\n        token = state.push('dd_close', 'dd', -1);\n\n        itemLines[1] = nextLine = state.line;\n\n        if (nextLine >= endLine) { break OUTER; }\n\n        if (state.sCount[nextLine] < state.blkIndent) { break OUTER; }\n        contentStart = skipMarker(state, nextLine);\n        if (contentStart < 0) { break; }\n\n        ddLine = nextLine;\n\n        // go to the next loop iteration:\n        // insert DD tag and repeat checking\n      }\n\n      if (nextLine >= endLine) { break; }\n      dtLine = nextLine;\n\n      if (state.isEmpty(dtLine)) { break; }\n      if (state.sCount[dtLine] < state.blkIndent) { break; }\n\n      ddLine = dtLine + 1;\n      if (ddLine >= endLine) { break; }\n      if (state.isEmpty(ddLine)) { ddLine++; }\n      if (ddLine >= endLine) { break; }\n\n      if (state.sCount[ddLine] < state.blkIndent) { break; }\n      contentStart = skipMarker(state, ddLine);\n      if (contentStart < 0) { break; }\n\n      // go to the next loop iteration:\n      // insert DT and DD tags and repeat checking\n    }\n\n    // Finilize list\n    token = state.push('dl_close', 'dl', -1);\n\n    listLines[1] = nextLine;\n\n    state.line = nextLine;\n\n    // mark paragraphs tight if needed\n    if (tight) {\n      markTightParagraphs(state, listTokIdx);\n    }\n\n    return true;\n  }\n\n\n  md.block.ruler.before('paragraph', 'deflist', deflist, { alt: [ 'paragraph', 'reference', 'blockquote' ] });\n};\n", "export default require(\"./node_modules/markdown-it-deflist/index.js\");"],
  "mappings": "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",
  "names": []
}
