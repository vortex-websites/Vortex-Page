import {
  __commonJS
} from "./chunk-FJLWZCXQ.js";

// node_modules/markdown-it-ins/index.js
var require_markdown_it_ins = __commonJS({
  "node_modules/markdown-it-ins/index.js"(exports, module) {
    "use strict";
    module.exports = function ins_plugin(md) {
      function tokenize(state, silent) {
        var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
        if (silent) {
          return false;
        }
        if (marker !== 43) {
          return false;
        }
        scanned = state.scanDelims(state.pos, true);
        len = scanned.length;
        ch = String.fromCharCode(marker);
        if (len < 2) {
          return false;
        }
        if (len % 2) {
          token = state.push("text", "", 0);
          token.content = ch;
          len--;
        }
        for (i = 0; i < len; i += 2) {
          token = state.push("text", "", 0);
          token.content = ch + ch;
          if (!scanned.can_open && !scanned.can_close) {
            continue;
          }
          state.delimiters.push({
            marker,
            length: 0,
            jump: i / 2,
            token: state.tokens.length - 1,
            end: -1,
            open: scanned.can_open,
            close: scanned.can_close
          });
        }
        state.pos += scanned.length;
        return true;
      }
      function postProcess(state, delimiters) {
        var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
        for (i = 0; i < max; i++) {
          startDelim = delimiters[i];
          if (startDelim.marker !== 43) {
            continue;
          }
          if (startDelim.end === -1) {
            continue;
          }
          endDelim = delimiters[startDelim.end];
          token = state.tokens[startDelim.token];
          token.type = "ins_open";
          token.tag = "ins";
          token.nesting = 1;
          token.markup = "++";
          token.content = "";
          token = state.tokens[endDelim.token];
          token.type = "ins_close";
          token.tag = "ins";
          token.nesting = -1;
          token.markup = "++";
          token.content = "";
          if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "+") {
            loneMarkers.push(endDelim.token - 1);
          }
        }
        while (loneMarkers.length) {
          i = loneMarkers.pop();
          j = i + 1;
          while (j < state.tokens.length && state.tokens[j].type === "ins_close") {
            j++;
          }
          j--;
          if (i !== j) {
            token = state.tokens[j];
            state.tokens[j] = state.tokens[i];
            state.tokens[i] = token;
          }
        }
      }
      md.inline.ruler.before("emphasis", "ins", tokenize);
      md.inline.ruler2.before("emphasis", "ins", function(state) {
        var curr, tokens_meta = state.tokens_meta, max = (state.tokens_meta || []).length;
        postProcess(state, state.delimiters);
        for (curr = 0; curr < max; curr++) {
          if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
            postProcess(state, tokens_meta[curr].delimiters);
          }
        }
      });
    };
  }
});

// dep:markdown-it-ins
var markdown_it_ins_default = require_markdown_it_ins();
export {
  markdown_it_ins_default as default
};
//# sourceMappingURL=markdown-it-ins.js.map
